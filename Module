-------------------------------------------------------------------------------------------------------------------------------------
1. ini_file – Tweak settings in INI files

Manage (add, remove, change) individual settings in an INI-style file without having to manage the file as a whole with, say, 
template or assemble. Adds missing sections if they don’t exist.

Ex:- 
# Before 2.3, option 'dest' was used instead of 'path'
- name: Ensure "fav=lemonade is in section "[drinks]" in specified file
  ini_file:
    path: /etc/conf
    section: drinks
    option: fav
    value: lemonade
    mode: 0600
    backup: yes

------------------------------------------------------------------------------------------------------------------------------------

2. include_vars – Load variables from files, dynamically within a task

-Loads variables from a YAML/JSON files dynamically from within a file or from a directory recursively during task runtime. 
If loading a directory, the files are sorted alphabetically before being loaded.
-This module is also supported for Windows targets.


Ex:-
----------
From Apache Installation Module:- 

# Include variables and define needed variables.
- name: Include OS-specific variables.
  include_vars: "{{ ansible_os_family }}.yml"

- name: Include variables for Amazon Linux.
  include_vars: "AmazonLinux.yml"
  when:
    - ansible_distribution == "Amazon"
    - ansible_distribution_major_version == "NA"
----------


- name: Include vars of stuff.yaml into the 'stuff' variable (2.2).
  include_vars:
    file: stuff.yaml
    name: stuff

- name: Conditionally decide to load in variables into 'plans' when x is 0, otherwise do not. (2.2)
  include_vars:
    file: contingency_plan.yaml
    name: plans
  when: x == 0

- name: Load a variable file based on the OS type, or a default if not found. Using free-form to specify the file.
  include_vars: "{{ item }}"
  with_first_found:
    - "{{ ansible_distribution }}.yaml"
    - "{{ ansible_os_family }}.yaml"
    - default.yaml

- name: Bare include (free-form)
  include_vars: myvars.yaml

- name: Include all .json and .jsn files in vars/all and all nested directories (2.3)
  include_vars:
    dir: vars/all
    extensions:
        - json
        - jsn

- name: Include all default extension files in vars/all and all nested directories and save the output in test. (2.2)
  include_vars:
    dir: vars/all
    name: test

- name: Include default extension files in vars/services (2.2)
  include_vars:
    dir: vars/services
    depth: 1

- name: Include only files matching bastion.yaml (2.2)
  include_vars:
    dir: vars
    files_matching: bastion.yaml

- name: Include all .yaml files except bastion.yaml (2.3)
  include_vars:
    dir: vars
    ignore_files: [bastion.yaml]
    extensions: [yaml]

-------------------------------------------------------------------------------------------------------------------------------------

3. set_fact – Set host facts from a task

- This module allows setting new variables. Variables are set on a host-by-host basis just like facts discovered by the setup module.
- These variables will be available to subsequent plays during an ansible-playbook run, but will not be saved across executions even if 
  you use a fact cache.
- Per the standard Ansible variable precedence rules, many other types of variables have a higher priority, so this value may be 
  overridden. See Variable Precedence Guide for more information.
- This module is also supported for Windows targets.

---------------------------------------------------------------------------------------------------------------------------------------
4. script – Runs a local script on a remote node after transferring it

- The script module takes the script name followed by a list of space-delimited arguments.
- The local script at path will be transferred to the remote node and then executed.
- The given script will be processed through the shell environment on the remote node.
- This module does not require python on the remote system, much like the raw module.
- This module is also supported for Windows targets.

--------------------------------------------------------------------------------------------------------------------------------------

5. command – Executes a command on a remote node
-------------------------------------------------------------------------------------------------------------------------------------
6. Including and Importing:-
Includes vs. Imports:-
As noted in Creating Reusable Playbooks, include and import statements are very similar, however the Ansible executor engine treats 
them very differently.

All import* statements are pre-processed at the time playbooks are parsed.
All include* statements are processed as they encountered during the execution of the playbook.


Note:- Also be aware that this behaviour changed in 2.4; prior to that Ansible version only include was available, 
and it behaved differently depending on context.


Importing Playbooks:-
It is possible to include playbooks inside a master playbook. For example:

---
- import_playbook: webservers.yml
- import_playbook: databases.yml
The plays and tasks in each playbook listed will be run in the order they are listed, just as if they had been defined here directly.

Prior to 2.4 only include was available and worked for both playbooks and tasks as both import and include.

Including and Importing Task Files:-
Use of included task lists is a great way to define a role that system is going to fulfill. A task include file simply
contains a flat list of tasks:

# common_tasks.yml
---
- name: placeholder foo
  command: /bin/foo
- name: placeholder bar
  command: /bin/bar
  
 
 You can then use import_tasks or include_tasks to include this file in your main task list:
 
 tasks:
- import_tasks: common_tasks.yml
# or
- include_tasks: common_tasks.yml

You can also pass variables into imports and includes:

tasks:
- import_tasks: wordpress.yml wp_user=timmy
- import_tasks: wordpress.yml wp_user=alice
- import_tasks: wordpress.yml wp_user=bob


Variables can also be passed to include files using an alternative syntax, which also supports structured variables like dictionaries 
and lists:

tasks:
- include_tasks: wordpress.yml
  vars:
    wp_user: timmy
    ssh_keys:
    - "{{ lookup('file', 'keys/one.pub') }}"
    - "{{ lookup('file', 'keys/two.pub') }}"
    

Includes and imports can also be used in the handlers: section; for instance, if you want to define how to restart apache, 
you only have to do that once for all of your playbooks. You might make a handlers.yml that looks like:

# more_handlers.yml
---
- name: restart apache
  service: name=apache state=restarted
And in your main playbook file:

handlers:
- include_tasks: more_handlers.yml
# or
- import_tasks: more_handlers.yml    
    
Note:- Be sure to refer to the limitations/trade-offs for handlers noted in Creating Reusable Playbooks.

---------------------------------------------------------------------------------------------------------------------------------------
7. package – Generic OS package manager

- Installs, upgrade and removes packages using the underlying OS package manager.
- For Windows targets, use the win_package module instead.

-----
Examples
- name: install ntpdate
  package:
    name: ntpdate
    state: present

# This uses a variable as this changes per distribution.
- name: remove the apache package
  package:
    name: "{{ apache }}"
    state: absent
    
-----    

---------------------------------------------------------------------------------------------------------------------------------------
8. Filters :-
Filters in Ansible are from Jinja2, and are used for transforming data inside a template expression. Jinja2 ships with many filters. 
See builtin filters in the official Jinja2 template documentation.

Take into account that templating happens on the Ansible controller, not on the task’s target host, so filters also execute on the 
controller as they manipulate local data.

In addition the ones provided by Jinja2, Ansible ships with it’s own and allows users to add their own custom filters.

-----
To use one value on true and another on false (new in version 1.9):

{{ (name == "John") | ternary('Mr','Ms') }}

i.e docker_yum_repo_url: https://download.docker.com/linux/{{ (ansible_distribution == "Fedora") | ternary("fedora","centos") }}/docker-{{ docker_edition }}.repo

-------
To get the last name of a file path, like ‘foo.txt’ out of ‘/etc/asdf/foo.txt’:

{{ path | basename }}

-------
To get the directory from a path:

{{ path | dirname }}
-------
For more filter refer docs



---------------------------------------------------------------------------------------------------------------------------------------

9. ping – Try to connect to host, verify a usable python and return pong on success

Ping is used when we want to check whether the connection with our hosts defined in the inventory file is established or not.

# ansible test-servers -m ping -u ec2-user

ping changes to pong if an SSH connection is established.

------------------------------------------------------------------------------------------------------------------------------------

10. setup – Gathers facts about remote hosts

This module is automatically called by playbooks to gather useful variables about remote hosts that can be used in playbooks. 
It can also be executed directly by /usr/bin/ansible to check what variables are available to a host. Ansible provides many facts 
about the system, automatically.

This module is also supported for Windows targets.

# ansible test-servers -m setup -u ec2-user

------------------------------------------------------------------------------------------------------------------------------------

11. copy – Copy files to remote locations

- The copy module copies a file from the local or remote machine to a location on the remote machine.
- Use the fetch module to copy files from remote locations to the local box.
- If you need variable interpolation in copied files, use the template module. Using a variable in the content field will result in 
unpredictable output.
- For Windows targets, use the win_copy module instead.

- name: Copy file with owner and permissions
  copy:
    src: /srv/myfiles/foo.conf
    dest: /etc/foo.conf
    owner: foo
    group: foo
    mode: '0644'

- name: Copy file with owner and permission, using symbolic representation
  copy:
    src: /srv/myfiles/foo.conf
    dest: /etc/foo.conf
    owner: foo
    group: foo
    mode: u=rw,g=r,o=r

- name: Another symbolic mode example, adding some permissions and removing others
  copy:
    src: /srv/myfiles/foo.conf
    dest: /etc/foo.conf
    owner: foo
    group: foo
    mode: u+rw,g-wx,o-rwx

- name: Copy a new "ntp.conf file into place, backing up the original if it differs from the copied version
  copy:
    src: /mine/ntp.conf
    dest: /etc/ntp.conf
    owner: root
    group: root
    mode: '0644'
    backup: yes
    
 - name: Copy a new "sudoers" file into place, after passing validation with visudo
  copy:
    src: /mine/sudoers
    dest: /etc/sudoers
    validate: /usr/sbin/visudo -cf %s

- name: Copy a "sudoers" file on the remote machine for editing
  copy:
    src: /etc/sudoers
    dest: /etc/sudoers.edit
    remote_src: yes
    validate: /usr/sbin/visudo -cf %s

- name: Copy using inline content
  copy:
    content: '# This file was moved to /etc/other.conf'
    dest: /etc/mine.conf

- name: If follow=yes, /path/to/file will be overwritten by contents of foo.conf
  copy:
    src: /etc/foo.conf
    dest: /path/to/link  # link to /path/to/file
    follow: yes

- name: If follow=no, /path/to/link will become a file and be overwritten by contents of foo.conf
  copy:
    src: /etc/foo.conf
    dest: /path/to/link  # link to /path/to/file
    follow: no   
    
------------------------------------------------------------------------------------------------------------------------------------

12. fetch – Fetch files from remote nodes

This module works like copy, but in reverse.
It is used for fetching files from remote machines and storing them locally in a file tree, organized by hostname.
This module is also supported for Windows targets.

- name: Store file into /tmp/fetched/host.example.com/tmp/somefile
  fetch:
    src: /tmp/somefile
    dest: /tmp/fetched

- name: Specifying a path directly
  fetch:
    src: /tmp/somefile
    dest: /tmp/prefix-{{ inventory_hostname }}
    flat: yes

- name: Specifying a destination path
  fetch:
    src: /tmp/uniquefile
    dest: /tmp/special/
    flat: yes

- name: Storing in a path relative to the playbook
  fetch:
    src: /tmp/uniquefile
    dest: special/prefix-{{ inventory_hostname }}
    flat: yes
    
--------------------------------------------------------------------------------------------------------------------------------




------------------------------------------------------------------------------------------------------------------------------------






